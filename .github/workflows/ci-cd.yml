name: CI Pipeline

# CI/CD Workflow Structure:
# ==========================
# This workflow is optimized to avoid redundant dependency installation by using a dedicated
# preparation job that sets up Poetry and caches dependencies for all subsequent jobs.
#
# Workflow Graph:
#   prepare
#      ‚îú‚îÄ‚îÄ django-checks (system checks + linting)
#      ‚îî‚îÄ‚îÄ test (run tests with coverage, only on PRs)
#           ‚îî‚îÄ‚îÄ deploy-develop (only on push to master)
#
# Benefits:
# - Reduces repetitive dependency installation, accelerating CI/CD runs
# - Dependencies are installed once in the 'prepare' job
# - All other jobs restore from cache only (fail if cache is missing)
# - Test and check jobs run in parallel after preparation
# - Consistent and maintainable job structure

on:
  pull_request:
    branches: [master]
  push:
    branches: [master]

env:
  PYTHON_VERSION: "3.12"

jobs:
  # Prepare job: Sets up Poetry and installs all dependencies once
  # This job runs first and caches everything for subsequent jobs
  prepare:
    name: Setup Poetry & Install Dependencies
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        id: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache Poetry installation
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/share/pypoetry
            ~/.local/bin/poetry
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

  # Django checks job: Runs system checks and linting
  # Depends on 'prepare' job and restores cached dependencies
  django-checks:
    name: Django System Checks
    runs-on: ubuntu-latest
    needs: [prepare]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        id: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Restore Poetry from cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.local/share/pypoetry
            ~/.local/bin/poetry
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}
          fail-on-cache-miss: true

      - name: Restore venv from cache
        uses: actions/cache/restore@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
          fail-on-cache-miss: true

      - name: Create environment file
        run: |
          cat > .env << 'EOF'
          DEBUG=false
          SECRET_KEY=test-secret-key-for-ci
          DATABASE_URL=sqlite:///db.sqlite3
          REDIS_URL=redis://localhost:6379/0
          ALLOWED_HOSTS=localhost,127.0.0.1
          EOF

      - name: Run Django system checks
        run: |
          source .venv/bin/activate
          ENVIRONMENT=test python manage.py check

      - name: Run pre-commit hooks
        env:
          SKIP: no-commit-to-branch
        run: |
          source .venv/bin/activate
          pre-commit run

  # Test job: Runs the test suite with coverage
  # Depends on 'prepare' job (runs independently from django-checks)
  # Restores cached dependencies without reinstalling
  test:
    name: Tests with Coverage
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    needs: [prepare]

    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_USER: backend
          POSTGRES_DB: backend
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        id: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Restore Poetry from cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.local/share/pypoetry
            ~/.local/bin/poetry
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}
          fail-on-cache-miss: true

      - name: Restore venv from cache
        uses: actions/cache/restore@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
          fail-on-cache-miss: true

      - name: Create environment file
        run: |
          cat > .env << 'EOF'
          DEBUG=false
          SECRET_KEY=test-secret-key-for-ci
          DATABASE_URL=postgres://backend:password@localhost:5432/backend
          REDIS_URL=redis://localhost:6379/0
          ALLOWED_HOSTS=localhost,127.0.0.1
          EOF

      - name: Restore pytest cache
        uses: actions/cache@v4
        with:
          path: .pytest_cache
          key: pytest-${{ runner.os }}-${{ hashFiles('**/*.py', '**/pytest.ini', '**/pyproject.toml') }}
          restore-keys: |
            pytest-${{ runner.os }}-

      - name: Run tests
        run: |
          source .venv/bin/activate
          # Run tests with optimized settings for CI/CD
          # --dist=loadgroup: distribute tests by module for better caching
          # -n auto: use all available CPU cores
          # --maxfail=10: fail fast after 10 failures
          ENVIRONMENT=test python -m pytest apps/ \
            -v \
            --tb=short \
            --cov=apps \
            --cov-report=xml \
            -n auto \
            --dist=loadgroup \
            --maxfail=10

      - name: Upload coverage to Codecov
        if: success()
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  # Deploy job: Deploys to development environment
  # Depends on both django-checks and test jobs to ensure all validations pass
  # Only runs on push to master branch
  deploy-develop:
    name: Deploy to Develop Environment
    runs-on: ubuntu-latest
    environment: test
    needs: [django-checks]
    # Only run deployment on push to master (not on pull requests) and only if all checks passed
    # Additionally, deployment is controlled by ENABLE_DEPLOY flag (default: false)
    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && vars.ENABLE_DEPLOY == 'true'

    steps:
      - name: Deploy to EC2 Develop Server
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.DEVELOP_HOST }}
          username: ${{ secrets.DEVELOP_USERNAME }}
          key: ${{ secrets.DEVELOP_SSH_KEY }}
          script: |
            (
              set -Eeuo pipefail
              trap 'echo "‚ùå Deploy failed at line $LINENO"; exit 1' ERR

              echo "üöÄ [1/7] Go to project directory"
              cd /home/ubuntu/maivietland/backend

              echo "üîÑ [2/7] Update source code"
              git fetch --all --prune
              git checkout master
              git pull origin master

              echo "üìù [3/7] Update API_DOC_VERSION"
              API_DOC_VERSION=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              if grep -q "^API_DOC_VERSION=" .env 2>/dev/null; then
                sed -i "s/^API_DOC_VERSION=.*/API_DOC_VERSION=$API_DOC_VERSION/" .env
              else
                echo "API_DOC_VERSION=$API_DOC_VERSION" >> .env
              fi

              echo "üì¶ [4/7] Install dependencies (poetry --sync)"
              export PATH="$HOME/.local/bin:$PATH"
              poetry config virtualenvs.in-project true
              poetry install --no-interaction --no-root --without dev --sync

              echo "üóÑÔ∏è [5/7] Run Django management commands"
              poetry run python manage.py migrate --noinput
              poetry run python manage.py collectstatic --noinput
              poetry run python manage.py compilemessages -l vi
              poetry run python manage.py collect_permissions
              poetry run python manage.py upload_import_templates
              poetry run python manage.py sync_roles_from_excel

              echo "üîÅ [6/7] Restart supervisor services"
              sudo supervisorctl reread
              sudo supervisorctl update

              SERVICES=(
                maivietland-api
                maivietland-worker
                maivietland-beat
                maivietland-consume-audit-logs
                maivietland-realtime-attendance-listener
              )

              for svc in "${SERVICES[@]}"; do
                echo "   ‚Üª Restarting $svc"
                sudo supervisorctl restart "$svc"
              done

              echo "üåê [7/7] Reload nginx"
              sudo nginx -t
              sudo nginx -s reload

              echo "‚úÖ Deploy completed successfully"
            ) 2>&1 | sed '/^[[:space:]]*$/d'

      - name: Health Check (with retry)
        run: |
          set -Eeuo pipefail
          url="${{ vars.DEVELOP_APP_URL }}/health/"
          for i in {1..10}; do
            status=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 10 "$url") || status="000"
            if [ "$status" = "200" ]; then
              echo "‚úÖ Deploy th√†nh c√¥ng: 200 OK (attempt $i)"
              exit 0
            fi
            echo "‚è≥ Ch∆∞a s·∫µn s√†ng (HTTP $status) ‚Äî th·ª≠ l·∫°i ($i/10)"; sleep 5
          done
          echo "‚ùå Deploy th·∫•t b·∫°i: kh√¥ng nh·∫≠n ƒë∆∞·ª£c 200 OK sau 10 l·∫ßn th·ª≠"
          exit 1

      - name: Notify Deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: "DEVELOP deployment completed with status: ${{ job.status }}"
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
